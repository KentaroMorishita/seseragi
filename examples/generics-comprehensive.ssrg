// Seseragi ジェネリクス機能 - 総合サンプル

// 1. 基本的なジェネリック関数
fn identity<T> x: T -> T = x

// 2. 複数の型パラメータを持つ関数
fn constance<A, B> a: A -> b: B -> A = a

// 3. ジェネリック関数の使用例（型推論）
let intResult = identity 42
let stringResult = identity "hello"
let boolResult = identity true

show intResult
show stringResult
show boolResult

// 4. 明示的な型引数を指定した関数呼び出し
let explicitString = identity<String> "world"
let explicitInt = identity<Int> 100

show explicitString
show explicitInt

// 5. 複数型パラメータの関数使用
let constanceResult = constance 42 "ignored"

show constanceResult

// 6. 高階関数のジェネリクス
fn twice<T> f: (T -> T) -> x: T -> T = f (f x)

// 7. 高階関数の使用例
let addOne = \x -> x + 1
let twiceAddOne = twice addOne 5

show twiceAddOne

// 8. ネストした関数呼び出し
let nestedResult = constance (identity 42) "ignored"

show nestedResult

// 9. 基本的なジェネリック型エイリアス
type Box<T> = T

// 10. 複数型パラメータの型エイリアス
type Pair<A, B> = (A, B)

// 11. レコード型でのジェネリクス
type Container<T> = { value: T, metadata: String }

// 12. ネストしたジェネリック型
type Array<T> = List<T>

// ===== 実際にジェネリック型を使用する例 =====

// Box<T>を使用する変数宣言
let intBox: Box<Int> = 42
let stringBox: Box<String> = "hello"

show intBox
show stringBox

// Pair<A, B>を使用する変数宣言
let pairIntString: Pair<Int, String> = (42, "hello")
let pairBoolFloat: Pair<Bool, Float> = (true, 3.14)

// Container<T>を使用する変数宣言
let intContainer: Container<Int> = { value: 42, metadata: "number" }
let stringContainer: Container<String> = { value: "hello", metadata: "text" }

show pairIntString
show pairBoolFloat
show intContainer
show stringContainer

// ジェネリック型を返す関数
fn makeBox<T> value: T -> T = value
fn wrapValue<T> value: T -> T = value

// ジェネリック型を使った関数呼び出し
let wrappedInt = wrapValue 42
let wrappedString = wrapValue "hello"

show wrappedInt
show wrappedString

// 関数型を含むジェネリクス
fn apply<A, B> f: (A -> B) -> x: A -> B = f x

// 型注釈付きの変数宣言
let typedResult: String = identity<String> "typed"

// 複雑な型推論の例
let complexResult = apply (twice addOne) 10

// チェーン化された関数呼び出し
let chainedResult = apply identity (identity 42)

// 関数の部分適用とジェネリクス
let partialConstance = constance 42
let finalResult = partialConstance "ignored"

// ラムダ式でのジェネリクス型推論
let lambdaMap = \f -> \x -> f x
let mappedResult = lambdaMap identity 123

show complexResult
show chainedResult
show finalResult
show mappedResult
