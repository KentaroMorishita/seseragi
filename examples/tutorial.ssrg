// Seseragi 言語チュートリアル - 実装済み構文のみ

print "=== Seseragi Tutorial ==="

// =============================================================================
// 基本型と変数
// =============================================================================

print "--- Basic Types ---"

// 整数
let intValue = 42
let negativeInt = -10
let zero = 0

// 文字列
let stringValue = "Hello, Seseragi!"
let emptyString = ""

// 真偽値
let trueValue = True
let falseValue = False

print intValue
print stringValue
print trueValue

// =============================================================================
// 算術演算
// =============================================================================

print "--- Arithmetic Operations ---"

let sum = 10 + 5
let difference = 20 - 8
let product = 6 * 7
let quotient = 15 / 3
let remainder = 17 % 5

print sum
print difference
print product
print quotient
print remainder

// =============================================================================
// 比較演算
// =============================================================================

print "--- Comparison Operations ---"

let isEqual = 5 == 5
let isNotEqual = 5 != 3
let isLess = 3 < 5
let isGreater = 7 > 4
let isLessOrEqual = 3 <= 3
let isGreaterOrEqual = 8 >= 8

print isEqual
print isNotEqual
print isLess
print isGreater

// =============================================================================
// 関数定義（引数なし）
// =============================================================================

print "--- Functions without Arguments ---"

fn getMessage -> String = "Hello from function!"
fn getNumber -> Int = 42

let message = getMessage()
let number = getNumber()

print message
print number

// =============================================================================
// 関数定義（引数あり）
// =============================================================================

print "--- Functions with Arguments ---"

// 単一引数の関数
fn double x :Int -> Int = x * 2
fn negate x :Int -> Int = -x
fn isPositive x :Int -> Bool = x > 0

// 複数引数の関数（カリー化）
fn add x :Int -> y :Int -> Int = x + y
fn multiply x :Int -> y :Int -> Int = x * y
fn max x :Int -> y :Int -> Int = if x > y then x else y

let doubled = double 7
let negated = negate 10
let positive = isPositive 5

print doubled
print negated
print positive

let sum2 = add 10 5
let product2 = multiply 3 4
let maximum = max 10 5

print sum2
print product2
print maximum

// =============================================================================
// ブロック形式の関数定義
// =============================================================================

print "--- Block Functions ---"

fn processNumber x :Int -> Int {
  let doubled = x * 2
  let incremented = doubled + 1
    incremented
}

fn complexCalculation a :Int -> b :Int -> Int {
  let sum = a + b
  let product = a * b
    if sum > product then sum else product
}

let processed = processNumber 5
let calculated = complexCalculation 5 6

print processed
print calculated

// =============================================================================
// if-then-else
// =============================================================================

print "--- Conditionals ---"

fn abs x :Int -> Int = if x < 0 then -x else x
fn min x :Int -> y :Int -> Int = if x < y then x else y

let absolute = abs 42
let minimum = min 10 5

print absolute
print minimum

// =============================================================================
// 再帰関数
// =============================================================================

print "--- Recursive Functions ---"

fn factorial n :Int -> Int =
  if n <= 1 then 1 else n * factorial (n - 1)

fn fibonacci n :Int -> Int =
  if n <= 1 then n
  else fibonacci (n - 1) + fibonacci (n - 2)

let fact5 = factorial 5
let fib7 = fibonacci 7

print fact5
print fib7

// =============================================================================
// Maybe型の基本
// =============================================================================

print "--- Maybe Type ---"

let someValue = Just 42
let nothingValue = Nothing

print someValue
print nothingValue

fn safeDivide x :Int -> y :Int -> Maybe<Int> =
  if y == 0 then Nothing else Just (x / y)

let divResult1 = safeDivide 10 2
let divResult2 = safeDivide 10 0

print divResult1
print divResult2

// =============================================================================
// Either型の基本
// =============================================================================

print "--- Either Type ---"

let successValue = Right 42
let errorValue = Left "Error occurred"

print successValue
print errorValue

fn parsePositive x :Int -> Either<String, Int> =
  if x > 0 then Right x else Left "Not a positive number"

let parsed1 = parsePositive 42
let parsed2 = parsePositive (-5)

print parsed1
print parsed2

// =============================================================================
// パターンマッチング（基本）
// =============================================================================

print "--- Pattern Matching ---"

// 簡単な条件分岐による数値判定（パターンマッチングの代わり）
fn numberToString n :Int -> String =
  if n == 0 then "zero"
  else if n == 1 then "one"
  else if n == 2 then "two"
  else "other"

let numStr1 = numberToString 1
let numStr2 = numberToString 3

print numStr1
print numStr2

// 文字列判定の例
fn greet name :String -> String =
  if name == "Alice" then "Hello Alice!"
  else if name == "Bob" then "Hi Bob!"
  else "Hello stranger!"

let greeting1 = greet "Alice"
let greeting2 = greet "Charlie"

print greeting1
print greeting2

// =============================================================================
// カリー化と部分適用
// =============================================================================

print "--- Currying and Partial Application ---"

// カリー化された関数の部分適用
let add10 = add 10
let multiplyBy2 = multiply 2

let result1 = add10 5
let result2 = multiplyBy2 7

print result1
print result2

// =============================================================================
// 演算子の使用
// =============================================================================

print "--- Operators ---"

// パイプライン演算子
let pipeResult = 10 | double | add 5
print pipeResult

// FlatMap演算子（モナド操作）
let maybeResult = Just 10 >>= (\x :Int -> Just (x * 2))
print maybeResult

// =============================================================================
// ラムダ式（無名関数）
// =============================================================================

print "--- Lambda Expressions ---"

// ラムダ式の基本形
let addLambda = \x :Int -> \y :Int -> x + y
let squareLambda = \x :Int -> x * x

let lambdaResult1 = addLambda 5 3
let lambdaResult2 = squareLambda 7

print lambdaResult1
print lambdaResult2

// =============================================================================
// List型の基本
// =============================================================================

print "--- List Type ---"

// 空のリスト
let emptyList = Empty

// 要素を持つリスト
let singletonList = Cons 42 Empty
let multipleList = Cons 1 (Cons 2 (Cons 3 Empty))

print emptyList
print singletonList
print multipleList

// リストに要素を追加
let newList = Cons 0 multipleList
print newList

// 関数型プログラミングスタイルでのリスト構築
let numberList = Cons 10 (Cons 20 (Cons 30 Empty))
let stringList = Cons "hello" (Cons "world" Empty)

print numberList
print stringList

// Maybe型とList型の組み合わせ
let maybeList = Cons (Just 1) (Cons Nothing (Cons (Just 3) Empty))
print maybeList

// Either型とList型の組み合わせ
let eitherList = Cons (Right 42) (Cons (Left "error") (Cons (Right 100) Empty))
print eitherList

// =============================================================================
// List型を使った関数
// =============================================================================

print "--- List Functions ---"

// リストに要素を追加する関数
fn prepend x :Int -> lst :List<Int> -> List<Int> = Cons x lst

let prependedList = prepend 999 multipleList
print prependedList

// より複雑なリスト構造
let complexList = Cons 100 (Cons 200 (Cons 300 Empty))
let veryComplexList = prepend 50 (prepend 25 complexList)
print complexList
print veryComplexList

// =============================================================================
// List型の応用例
// =============================================================================

print "--- Advanced List Examples ---"

// ネストしたリスト（リストのリスト）
let listOfLists = Cons (Cons 1 (Cons 2 Empty)) (Cons (Cons 3 (Cons 4 Empty)) Empty)
print listOfLists

// 異なる型のリストを組み合わせ
fn wrapInMaybe x :Int -> Maybe<Int> = Just x

let wrappedValue = wrapInMaybe 42
let maybeWrappedList = Cons wrappedValue (Cons Nothing Empty)
print maybeWrappedList

// =============================================================================
// Record型の基本
// =============================================================================

print "--- Record Type ---"

// 基本的なRecord定義
let person = { name: "Alice", age: 30, city: "Tokyo" }
let laptop = { id: 1001, name: "Laptop", price: 89999 }

print person
print laptop

// Recordフィールドアクセス
let personName = person.name
let personAge = person.age
let laptopPrice = laptop.price

print personName
print personAge
print laptopPrice

// =============================================================================
// 入れ子レコード
// =============================================================================

print "--- Nested Records ---"

// 入れ子レコードの定義
let employee = {
  info: { name: "Bob", age: 25 },
  department: "Engineering",
  salary: 75000
}

let company = {
  name: "TechCorp",
  location: { city: "Tokyo", country: "Japan" },
  employees: 150
}

print employee
print company

// 入れ子レコードのフィールドアクセス
let employeeName = employee.info.name
let employeeAge = employee.info.age
let companyCity = company.location.city
let companyCountry = company.location.country

print employeeName
print employeeAge
print companyCity
print companyCountry

// =============================================================================
// 複雑な入れ子レコード
// =============================================================================

print "--- Complex Nested Records ---"

// より複雑な入れ子構造
let user = {
  profile: {
    personal: { firstName: "Carol", lastName: "Smith" },
    contact: { email: "carol@example.com", phone: "090-1234-5678" }
  },
  preferences: {
    theme: "dark",
    language: "ja",
    notifications: { email: True, push: False }
  },
  account: {
    id: 12345,
    created: "2024-01-15",
    verified: True
  }
}

print user

// 深い階層のフィールドアクセス
let firstName = user.profile.personal.firstName
let email = user.profile.contact.email
let theme = user.preferences.theme
let emailNotifications = user.preferences.notifications.email
let accountId = user.account.id

print firstName
print email
print theme
print emailNotifications
print accountId

// =============================================================================
// Recordと関数の組み合わせ
// =============================================================================

print "--- Records with Functions ---"

// Recordを受け取る関数（簡単な例）
fn getAge person :{ name: String, age: Int } -> Int =
  person.age

fn getPrice item :{ price: Int } -> Int =
  item.price

let ageResult = getAge person
let priceResult = getPrice laptop

print ageResult
print priceResult

// 新しいRecordを作成
let newPerson = { name: "David", age: 28 }
let smartphone = { id: 2001, name: "Smartphone", price: 65000 }

print newPerson
print smartphone

// 作成したRecordのフィールドアクセス
let newPersonName = newPerson.name
let newPersonAge = newPerson.age
let smartphoneName = smartphone.name
let smartphonePrice = smartphone.price

print newPersonName
print newPersonAge
print smartphoneName
print smartphonePrice

// =============================================================================
// Recordと他の型の組み合わせ
// =============================================================================

print "--- Records with Other Types ---"

// Maybe型とRecord型の組み合わせ
let maybeUser = Just ({ name: "Eve", score: 95 })
let noUser = Nothing

print maybeUser
print noUser

// Either型とRecord型の組み合わせ
let validData = Right ({ status: "success", value: 42 })
let errorData = Left "Invalid input"

print validData
print errorData

// List型とRecord型の組み合わせ
let userRecord1 = { name: "Frank", level: 5 }
let userRecord2 = { name: "Grace", level: 8 }
let userList = Cons userRecord1 (Cons userRecord2 Empty)

let scoreRecord1 = { player: "Alice", score: 1000 }
let scoreRecord2 = { player: "Bob", score: 850 }
let scoreList = Cons scoreRecord1 (Cons scoreRecord2 Empty)

print userList
print scoreList

print "Tutorial completed!"

